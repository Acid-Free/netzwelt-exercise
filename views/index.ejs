<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Home Page</title>
  <style>
    ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: none;
    }


    .caret {
      cursor: pointer;
      -webkit-user-select: none;
      /* Safari 3.1+ */
      -moz-user-select: none;
      /* Firefox 2+ */
      -ms-user-select: none;
      /* IE 10+ */
      user-select: none;
    }

    .caret::before {
      content: "\25B6";
      color: black;
      display: inline-block;
      margin-right: 6px;
    }

    .caret-down::before {
      -ms-transform: rotate(90deg);
      /* IE 9 */
      -webkit-transform: rotate(90deg);
      /* Safari */

      transform: rotate(90deg);
    }

    .nested {
      display: none;
    }

    .active {
      display: block;
    }
  </style>
</head>

<body>
  <h2>Territories</h2>
  <p>Here are the list of territories</p>
  <div id="territories-data" data-object="<%= JSON.stringify(territories) %>"></div>
  <script>
    // Assumption 1: sorted (not necessary though)
    // Assumption 2: every entry should be placed in the list
    // Assumption 3: every entry has a parent in the list(except null)

    // Data send by backend 
    const territoriesData = JSON.parse(document.querySelector("#territories-data").getAttribute("data-object"));
    // DOM element containing the territory tree to be appended to body
    const territoryTree = document.createElement("div");
    // object containing ids in a tree structure
    const tree = createObjectTree();
    // Used in populateElementTree to avoid adding nested class to first li
    let depth = -1;

    populateElementTree(territoryTree, tree);
    
    // Returns an object of ids with tree-like structure
    function createObjectTree() {
      // tree key => id; [] => list of child ids
      const tree = {
        null: []
      };
      for (const element of territoriesData) {
        const parentIndex = territoriesData.findIndex(({id}) => id === element.parent);
        // With the assumptions in mind, the only time where parent is missing from the territoriesData is when parent is null
        const parentId = territoriesData[parentIndex]?.id ?? "null";
        const parentChildrenList = getParent(tree, parentId);

        const currentObject = {
          [element.id]: []
        };
        // If Assumption 1, parentChildren will never be null (provided tree has the null key initially)
        parentChildrenList.push(currentObject);
      }

      return tree;
    }

    // Returns the parent object value if present; null otherwise
    function getParent(object, id) {
      for (const key in object) {
        if (key === id) {
          return object[key];
        }
        // If list is not empty, navigate through it as well
        if (Array.isArray(object[key]) && object[key].length > 0)
          for (const childObject of object[key]) {
            // Store the result, if not found, try other elements
            const result = getParent(childObject, id);
            if (result) return result;
          }
      }
    }

    // Assumption 1: objectTree is not empty
    function populateElementTree(elementTree, objectTree) {
      // Assumption 2: There is only one object entry
      const [id, children] = Object.entries(objectTree)[0];
      const name = getIdName(id);

      // ul surrounds potential children
      const ul = document.createElement("ul");

      // Create li for surrounding potential span and ul
      const li = document.createElement("li");
      if (++depth > 0) li.classList.add("nested");

      // Create span showing the title if there is at least one child
      if (children.length > 0) {
        const spanTitle = document.createElement("span");
        spanTitle.textContent = name;
        spanTitle.classList.add("caret");
        li.append(spanTitle);
      }

      // Only add a text content if the current element doesn't have a child
      else {
        li.textContent = name;
      }

      ul.append(li);
      elementTree.append(ul);

      // Iterate over the object children recursively
      for (const child of children) {
        populateElementTree(li, child);
      }
    }

    // Returns a valid name from territory id
    function getIdName(territoryId) {
      if (territoryId === "null") return "Philippines";
      output = territoriesData.find(({id}) => id === territoryId);
      return output.name;
    }

    // Initialize dom element visualization
    function initializeElements() {
      let toggler = [...document.querySelectorAll(".caret")];
      console.log(toggler);
      toggler.forEach((element) =>
        element.addEventListener("click", (e) => {
          console.log(e);
          [...e.target.parentElement.querySelectorAll(".nested")].forEach(
            (element) => element.classList.toggle("active")
          );
        })
      );
    }

    document.body.append(territoryTree);

    initializeElements();
  </script>
</body>

</html>